<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parallel Text Editor</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="page">
    <div class="top-bar">
      <div class="top-left">
        <h1>Parallel Text Editor</h1>
        <div class="top-left-row">
          <label>Section title:
            <input id="sectionTitleInput" type="text" placeholder="e.g. vimsika_15-22" />
          </label>
          <label class="inline-label">Add language:</label>
          <div class="inline-input">
            <input id="langCodeInput" type="text" placeholder="e.g. eng, rus, tib, chn" />
            <button id="addLangBtn" type="button" aria-label="Add language">+</button>
          </div>
          <button id="toggleAllBtn" type="button" class="toggle-all-btn">Collapse all</button>
        </div>
      </div>
      <div class="top-right">
        <div class="inline-buttons">
          <span>Add sentences:</span>
          <button id="add5Btn" type="button">+5</button>
          <button id="add10Btn" type="button">+10</button>
          <button id="add50Btn" type="button">+50</button>
        </div>
        <div class="inline-buttons">
          <input id="uploadJsonInput" type="file" accept="application/json" aria-label="Upload JSON" />
          <button id="uploadJsonBtn" type="button">Load JSON</button>
        </div>
      </div>
    </div>

    <div class="message-overlay" id="message">
      <span class="message-icon">⚠️</span>
      <span id="messageText"></span>
      <button type="button" id="messageClose" aria-label="Close message">✕</button>
    </div>
    <div id="pairsContainer" class="pairs"></div>

    <div class="download-row">
      <label>JSON file name:
        <input id="filenameJson" type="text" value="parallel-texts.json" />
      </label>
      <button id="downloadJsonBtn" type="button">Download JSON</button>

      <label>HTML file name:
        <input id="filenameHtml" type="text" value="parallel.html" />
      </label>
      <label class="inline-label"><input type="checkbox" id="inlineCssToggle" checked> Inline CSS</label>
      <button id="downloadHtmlBtn" type="button">Download HTML</button>
    </div>

  </div>

  <script>
    let pairCount = 0;
    const languages = [];
    const pairsContainer = document.getElementById("pairsContainer");
    const add5Btn = document.getElementById("add5Btn");
    const add10Btn = document.getElementById("add10Btn");
    const add50Btn = document.getElementById("add50Btn");
    const toggleAllBtn = document.getElementById("toggleAllBtn");
    const addLangBtn = document.getElementById("addLangBtn");
    const uploadJsonBtn = document.getElementById("uploadJsonBtn");
    const uploadJsonInput = document.getElementById("uploadJsonInput");
    const downloadJsonBtn = document.getElementById("downloadJsonBtn");
    const downloadHtmlBtn = document.getElementById("downloadHtmlBtn");
    const inlineCssToggle = document.getElementById("inlineCssToggle");
    const messageEl = document.getElementById("message");
    const messageText = document.getElementById("messageText");
    const messageClose = document.getElementById("messageClose");
    const sectionTitleInput = document.getElementById("sectionTitleInput");
    const langCodeInput = document.getElementById("langCodeInput");

// Singleton manager for batched resizing
const resizeManager = {
  queue: new Set(),
  rafId: null,

  // The public function to call
  add(textarea) {
    this.queue.add(textarea);
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => this.flush());
    }
  },

  flush() {
    this.rafId = null; 
    const validElements = Array.from(this.queue).filter(ta => ta.isConnected);
    this.queue.clear();

    if (validElements.length === 0) return;

    for (const ta of validElements) {
      ta.style.height = 'auto';
    }

    const measurements = validElements.map(ta => ({
      element: ta,
      height: ta.scrollHeight
    }));

    for (const m of measurements) {
      m.element.style.height = `${m.height}px`;
    }
  }
};

// Update your helper function to use the manager
function autoResize(textarea) {
  resizeManager.add(textarea);
}

    function createPairElement(index) {
      const pairDiv = document.createElement("div");
      pairDiv.className = "pair";
      pairDiv.dataset.index = index;
      pairDiv.innerHTML = `
        <div class="pair-header-row">
          <div class="pair-header">
            <button type="button" class="pair-toggle" aria-label="Toggle sentence">▼</button>
            <span class="pair-title">
              <span class="pair-index">[${index}]</span>
              <span class="pair-preview" id="preview-${index}"></span>
            </span>
            <label class="root-inline"><input type="checkbox" id="root-${index}"> Root text</label>
          </div>
          <div class="pair-actions">
            <button type="button" class="insert-before-btn" aria-label="Add sentence before">▲+</button>
            <button type="button" class="insert-after-btn" aria-label="Add sentence after">▼+</button>
            <button type="button" class="remove-pair-btn" aria-label="Remove sentence">✕</button>
          </div>
        </div>
        <div class="pair-body">
          <div class="pair-fields">
            <div class="field">
              <label for="original-${index}">Original</label>
              <textarea id="original-${index}"></textarea>
            </div>
          </div>
        </div>
      `;
      return pairDiv;
    }

    function addLanguageToPair(pair, lang, slug, index) {
      const pairFields = pair.querySelector(".pair-fields");
      const field = document.createElement("div");
      field.className = "field";

      const label = document.createElement("label");
      label.htmlFor = `translation-${slug}-${index}`;
      label.textContent = `Translation (${lang.toUpperCase()})`;

      const ta = document.createElement("textarea");
      ta.id = `translation-${slug}-${index}`;

      field.appendChild(label);
      field.appendChild(ta);
      pairFields.appendChild(field);
      autoResize(ta);
      ta.addEventListener("input", () => autoResize(ta));
    }

    function addLanguagesToPair(pair, index) {
      languages.forEach(({ lang, slug }) => addLanguageToPair(pair, lang, slug, index));
    }

    function setPairCollapsed(pair, collapsed) {
      const body = pair.querySelector(".pair-body");
      const toggle = pair.querySelector(".pair-toggle");
      const root = pair.querySelector(".root-inline");
      const preview = pair.querySelector(".pair-preview");
      if (preview) {
        const idx = pair.dataset.index || "";
        const orig = pair.querySelector(`#original-${idx}`);
        const text = orig ? orig.value.trim().split(/\s+/).slice(0, 6).join(" ") : "";
        preview.textContent = collapsed ? ` ${text}${text ? "…" : ""}` : "";
        preview.classList.toggle("rooted", root?.querySelector("input")?.checked && collapsed);
      }
      if (body) body.style.display = collapsed ? "none" : "block";
      if (root) root.style.display = collapsed ? "none" : "inline-flex";
      if (toggle) toggle.textContent = collapsed ? "►" : "▼";
      pair.dataset.collapsed = collapsed ? "true" : "false";
    }

    function addPair() {
      const newIndex = pairCount + 1;
      const newPair = createPairElement(newIndex);
      pairsContainer.appendChild(newPair);
      attachTextareas(newPair);
      addLanguagesToPair(newPair, newIndex);
      setPairCollapsed(newPair, false);
      pairCount = newIndex;
    }

    function addMultiple(count) {
      // 1. Create a lightweight container (not in the visible DOM yet)
      const fragment = document.createDocumentFragment();
      
      for (let i = 0; i < count; i++) {
        const newIndex = pairCount + 1;
        pairCount = newIndex;
        
        const newPair = createPairElement(newIndex);
        
        // We attach logic, but "autoResize" will just queue it up
        attachTextareas(newPair); 
        addLanguagesToPair(newPair, newIndex);
        setPairCollapsed(newPair, false);
        
        fragment.appendChild(newPair);
      }
      
      // 2. The "Boom" - Insert 50 elements in ONE operation
      pairsContainer.appendChild(fragment);
      
      // 3. The resize manager will handle the heights in the next frame automatically
    }

    function toggleAllPairs(collapse) {
      document.querySelectorAll(".pair").forEach((pair) => {
        setPairCollapsed(pair, collapse);
      });
      toggleAllBtn.textContent = collapse ? "Expand all" : "Collapse all";
    }

    add5Btn.addEventListener("click", () => addMultiple(5));
    add10Btn.addEventListener("click", () => addMultiple(10));
    add50Btn.addEventListener("click", () => addMultiple(50));
    toggleAllBtn.addEventListener("click", () => {
      const anyExpanded = Array.from(document.querySelectorAll(".pair")).some(
        (pair) => pair.dataset.collapsed !== "true"
      );
      toggleAllPairs(anyExpanded);
    });

    function reindexPairs() {
      const pairDivs = [...pairsContainer.querySelectorAll(".pair")];
      pairCount = pairDivs.length;
      pairDivs.forEach((pair, idx) => {
        const newIndex = idx + 1;
        const oldIndex = pair.dataset.index || newIndex;
        pair.dataset.index = newIndex;
        // Update the visible index while keeping the header layout intact
        const indexLabel = pair.querySelector(".pair-index");
        if (indexLabel) indexLabel.textContent = `[${newIndex}]`;
        // Update IDs for originals and roots
        const orig = pair.querySelector(`#original-${oldIndex}`) || pair.querySelector("textarea[id^='original-']");
        if (orig) {
          orig.id = `original-${newIndex}`;
          orig.previousElementSibling?.setAttribute("for", `original-${newIndex}`);
        }
        const root = pair.querySelector(`#root-${oldIndex}`) || pair.querySelector("input[id^='root-']");
        if (root) {
          root.id = `root-${newIndex}`;
          root.closest("label")?.setAttribute("for", `root-${newIndex}`);
        }
        // Update translation ids
        pair.querySelectorAll("textarea[id^='translation-']").forEach((ta) => {
          const parts = ta.id.split("-");
          const slug = parts.slice(1, -1).join("-");
          ta.id = `translation-${slug}-${newIndex}`;
          ta.previousElementSibling?.setAttribute("for", `translation-${slug}-${newIndex}`);
        });
      });
    }

    pairsContainer.addEventListener("click", (event) => {
      const pairDiv = event.target.closest(".pair");
      if (!pairDiv) return;
      if (event.target.classList.contains("remove-pair-btn")) {
        pairDiv.remove();
        reindexPairs();
      } else if (event.target.classList.contains("insert-before-btn")) {
        const beforeIndex = Number(pairDiv.dataset.index) || 1;
        const newPair = createPairElement(beforeIndex);
        addLanguagesToPair(newPair, beforeIndex);
        attachTextareas(newPair);
        setPairCollapsed(newPair, false);
        pairDiv.before(newPair);
        reindexPairs();
      } else if (event.target.classList.contains("insert-after-btn")) {
        const afterIndex = (Number(pairDiv.dataset.index) || 1) + 1;
        const newPair = createPairElement(afterIndex);
        addLanguagesToPair(newPair, afterIndex);
        attachTextareas(newPair);
        setPairCollapsed(newPair, false);
        pairDiv.after(newPair);
        reindexPairs();
      } else if (event.target.classList.contains("pair-toggle")) {
        const current = pairDiv.dataset.collapsed === "true";
        setPairCollapsed(pairDiv, !current);
      }
    });

    function attachTextareas(pairElement) {
      pairElement.querySelectorAll("textarea").forEach((ta) => {
        autoResize(ta);
        ta.addEventListener("input", () => autoResize(ta));
      });
      // Keep preview updated for this pair
      const orig = pairElement.querySelector("textarea[id^='original-']");
      if (orig) {
        orig.addEventListener("input", () => {
          const pair = orig.closest(".pair");
          if (pair) {
            setPairCollapsed(pair, pair.dataset.collapsed === "true");
          }
        });
      }
    }

    function slugifyLang(code) {
      return code.trim().replace(/[^a-z0-9_-]/gi, "-");
    }

    function addLanguageField(langCode) {
      const lang = langCode.trim();
      if (!lang) {
        showMessage("Please enter a language code.", "warn");
        return;
      }
      const exists = languages.some((l) => l.lang.toLowerCase() === lang.toLowerCase());
      if (exists) {
        showMessage(`Language "${lang}" already added.`, "warn");
        return;
      }
      const slug = slugifyLang(lang);
      languages.push({ lang, slug });
      document.querySelectorAll(".pair").forEach((pair, idx) => {
        const index = Number(pair.dataset.index) || idx + 1;
        addLanguageToPair(pair, lang, slug, index);
      });
      showMessage(`Added translation field for "${lang}".`);
    }

    addLangBtn.addEventListener("click", () => {
      addLanguageField(langCodeInput.value);
      langCodeInput.value = "";
    });

    function setsEqual(a, b) {
      if (a.size !== b.size) return false;
      for (const v of a) {
        if (!b.has(v)) return false;
      }
      return true;
    }

    function validateLanguageConsistency(sentences) {
      if (!sentences.length) return { valid: true, languages: [] };
      const sets = sentences.map(
        (s) => new Set(Object.keys(s.translations || {}))
      );
      const union = new Set();
      sets.forEach((s) => s.forEach((lang) => union.add(lang)));

      const baseline =
        sets.find((s) => s.size > 0) ||
        sets[0] ||
        new Set();
      let valid = true;
      for (const s of sets) {
        if (!setsEqual(s, baseline)) {
          valid = false;
          break;
        }
      }
      return { valid, languages: Array.from(union) };
    }

    let messageTimer = null;

    if (inlineCssToggle) {
      inlineCssToggle.checked = true;
    }

    function showMessage(text, type = "info") {
      if (messageTimer) {
        clearTimeout(messageTimer);
        messageTimer = null;
      }
      messageText.textContent = text;
      messageEl.className = type === "warn" ? "message-overlay warn" : "message-overlay";
      messageEl.style.display = text ? "flex" : "none";
      if (text && type !== "warn") {
        messageTimer = setTimeout(() => showMessage(""), 3000);
      }
    }

    messageClose.addEventListener("click", () => {
      showMessage("");
    });

    function resetEditor() {
      languages.length = 0;
      pairsContainer.innerHTML = "";
      pairCount = 0;
    }

    function normalizeData(raw) {
      if (Array.isArray(raw)) {
        if (raw.length && raw[0].sentences) return raw;
        return [{ sectionTitle: "Text", sentences: raw }];
      }
      if (raw && Array.isArray(raw.sections)) return raw.sections;
      throw new Error("Unsupported JSON shape. Expected an array of sections or sentences.");
    }

    function populateFromData(raw) {
      const sections = normalizeData(raw);
      resetEditor();
      const section = sections[0] || { sectionTitle: "Text", sentences: [] };
      sectionTitleInput.value = section.sectionTitle || "Text";
      const sentences = section.sentences || [];

      const { valid, languages: langs } = validateLanguageConsistency(sentences);

      // Prepare language objects with slugs
      languages.push(
        ...langs.map((lang) => ({ lang, slug: slugifyLang(lang) }))
      );

      sentences.forEach((s, idx) => {
        addPair();
        const currentIndex = idx + 1;
        const pair = pairsContainer.querySelectorAll(".pair")[idx];
        const orig = pair.querySelector(`#original-${currentIndex}`);
        if (orig) {
          orig.value = s.original || "";
          autoResize(orig);
        }
        const rootEl = pair.querySelector(`#root-${currentIndex}`);
        if (rootEl) rootEl.checked = !!s.root;
        Object.entries(s.translations || {}).forEach(([lang, text]) => {
          const slug = slugifyLang(lang);
          const ta = document.getElementById(`translation-${slug}-${currentIndex}`);
          if (ta) {
            ta.value = text || "";
            autoResize(ta);
          }
        });
      });
      if (!valid) {
        showMessage(`Inconsistent translation languages across sentences. Loaded ${section.sentences?.length || 0} sentence(s).`, "warn");
      } else {
        showMessage(`Loaded ${section.sentences?.length || 0} sentence(s) from JSON.`);
      }
    }

    async function readJsonFile(file) {
      const text = await file.text();
      return JSON.parse(text);
    }

    function hasUnsavedContent() {
      return Array.from(document.querySelectorAll("textarea")).some(
        (ta) => ta.value.trim().length > 0
      );
    }

    uploadJsonBtn.addEventListener("click", async () => {
      const file = uploadJsonInput.files && uploadJsonInput.files[0];
      if (!file) {
        showMessage("Please choose a JSON file to load.", "warn");
        return;
      }
      if (hasUnsavedContent()) {
        const proceed = window.confirm(
          "Loading a JSON will discard current content. Continue?"
        );
        if (!proceed) {
          showMessage("Upload cancelled to preserve current content.", "warn");
          return;
        }
      }
      try {
        const data = await readJsonFile(file);
        populateFromData(data);
      } catch (err) {
        showMessage(`Failed to load JSON: ${err.message}`, "warn");
      }
    });

    window.addEventListener("beforeunload", (event) => {
      if (hasUnsavedContent()) {
        event.preventDefault();
        event.returnValue = "";
      }
    });

    function collectPairs() {
      const data = [];
      for (let i = 1; i <= pairCount; i++) {
        const origEl = document.getElementById(`original-${i}`);
        const rootEl = document.getElementById(`root-${i}`);
        if (!origEl) continue;

        const original = origEl.value.trim();
        const root = rootEl ? rootEl.checked : false;
        const translations = {};
        let hasTranslation = false;
        languages.forEach(({ lang, slug }) => {
          const ta = document.getElementById(`translation-${slug}-${i}`);
          if (ta) {
            translations[lang] = ta.value.trim();
            if (translations[lang]) hasTranslation = true;
          }
        });

        if (!original && !hasTranslation) continue;

        data.push({
          original,
          translations,
          root,
        });
      }
      return data;
    }

    function buildSectionedData() {
      return [
        {
          sectionTitle: sectionTitleInput.value.trim() || "Text",
          sentences: collectPairs(),
        },
      ];
    }

    function downloadFile(content, filename, mime) {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    downloadJsonBtn.addEventListener("click", () => {
      const data = buildSectionedData();
      const filename = (document.getElementById("filenameJson").value.trim() || "parallel-texts.json");
      downloadFile(JSON.stringify(data, null, 2), filename, "application/json");
      showMessage(`Downloaded JSON with ${data[0].sentences.length} sentence(s) to ${filename}.`);
    });

    async function loadTemplate() {
      const url = new URL("template.html", window.location.href).toString();
      let resp;
      try {
        resp = await fetch(url, { cache: "no-cache" });
      } catch (err) {
        throw new Error(`Failed to load template.html. If you are opening this editor via file://, please run a local server (e.g. python3 -m http.server) and reload. Details: ${err.message}`);
      }
      if (!resp.ok) {
        throw new Error(`Failed to load template.html: ${resp.status}`);
      }
      return resp.text();
    }

    async function loadStyles() {
      const url = new URL("styles.css", window.location.href).toString();
      const resp = await fetch(url, { cache: "no-cache" });
      if (!resp.ok) {
        throw new Error(`Failed to load styles.css: ${resp.status}`);
      }
      return resp.text();
    }

    downloadHtmlBtn.addEventListener("click", async () => {
      try {
        const template = await loadTemplate();
        const data = buildSectionedData();
        const payload = JSON.stringify(data, null, 2);
        let filled = template.replace("__DATA__", payload);
        const shouldInlineCss = !inlineCssToggle || inlineCssToggle.checked;
        if (shouldInlineCss) {
          const css = await loadStyles();
          filled = filled.replace(
            '<link rel="stylesheet" href="styles.css">',
            `<style>\n${css}\n</style>`
          );
        }
        const filename = (document.getElementById("filenameHtml").value.trim() || "parallel.html");
        downloadFile(filled, filename, "text/html");
        showMessage(`Downloaded HTML with ${data[0].sentences.length} sentence(s) to ${filename}.`);
      } catch (err) {
        showMessage(err.message, "warn");
      }
    });

    // Seed with a single empty pair by default
    addPair();
  </script>
</body>
</html>
